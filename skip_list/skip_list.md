# skip list

skip list 中文翻译为跳跃表，简称跳表，其本质上是一种高效查找的特殊数据结构，解决查找问题的数据结构还有平衡树或者哈希表。

## 1 案例分析
学生成绩管理系统，按总分排序（倒序）如下：

|学号|语文|数学|英语|总分|
|-|-|-|-|-|
|1101|120|145|135|400|
|1103|130|133|135|398|
|1102|119|140|136|395|

按数学成绩排序（倒序）：

|学号|语文|数学|英语|总分|
|-|-|-|-|-|
|1101|120|145|135|400|
|1102|119|140|136|395|
|1103|130|133|135|398|

如果不是 3 个考生，而是 100w ，并且支持按学号，语文，数学，英语及总分排序，那该如何设计数据结构呢？（先不考虑 redis 的有序集合）。假设问题规模为 N，分析不同方案的复杂度。

### 1.1 方案 1：数组
特点：内存地址连续，可通过数组下标访问特定元素

使用数组存储时，分析增删改查的复杂度如下：
* 增：为了保证插入数据后数组仍保持有序性，可使用二分查找确定插入位置，查找过程的时间复杂度为 O(log2(N))，插入过程中，比插入数据小的记录都需要移动，时间复杂度为 O(N)，所以总体时间复杂度为 O(N)
* 删：使用二分查找确定待删除的数据，如有需要再移动部分数据，所以总体复杂度为 O(N)，分析：查找过程是 O(log2(N))
* 改：使用二分查找确定待修改的数据，无需移动记录，所以时间复杂度为 O(log2(N))
* 查：二分查找，时间复杂度为 O(log2(N))

### 1.2 方案 2: 链表
特点：内存地址不连续

使用链表存储时，分析增删改查的复杂度如下：
* 增：插入操作比较方便，无需移动记录，只需修改指针指向，时间复杂度为 O(1)，但是找到合适的插入位置的时间复杂度为 O(N)，所以整体复杂度为 O(N)
* 删：与插入过程类似，整体复杂度为 O(N)
* 改：查找到待修改的记录，时间复杂度为 O(N)，完成修改即可，所以时间复杂度为 O(N)
* 查：由于存储的内存地址不连续，无法使用二分查找，只能顺序遍历，所以时间复杂度为 O(N)

### 1.3 方案分析
* 数组的查找的时间复杂度为 O(N)，但是插入和删除操作都需要移动大量记录
* 链表的插入和删除只需修改指针指向，无需移动记录，但是查找的时间复杂度为 O(N)
* 显然，这两种方案都不适用于大规模的问题分析。

## 2 跳跃表
跳跃表是一种基于有序链表的扩展，由于链表不能使用二分查找法，所以跳跃表也无法使用二分法来提高查找效率。

为了提高查找效率，类似 MySQL 的索引，可以将链表中的部分节点作为索引，并将这些节点构成新的链表，从而减少遍历比较的节点数。

### 2.1 一级索引
* 假设使用链表奇数位上的节点作为一级索引节点，示例如下：

![01_first_index.jpg](https://github.com/wxdyhj/data-struct-go/blob/master/skip_list/jpg/01_first_index.jpg)

* 假设新节点的值是 5，分析插入过程：由于一级索引的存在，无需遍历原始链表，只需遍历比较一级索引链表上的值，示例如下：

![02_find_on_first_index.jpg](https://github.com/wxdyhj/data-struct-go/blob/master/skip_list/jpg/02_find_on_first_index.jpg)

* 在一级索引链表中，确定新节点 5 应该在 3 和 6 之间，因此回归原始链表，依次比较原始链表 3 之后的值，示例如下：

![03_return_origin_link_list.jpg](https://github.com/wxdyhj/data-struct-go/blob/master/skip_list/jpg/03_return_origin_link_list.jpg)

* 最终确定新节点 5 在 4 和 6 之间，在原始链表执行插入操作，示例如下：

![04_after_insertion.jpg](https://github.com/wxdyhj/data-struct-go/blob/master/skip_list/jpg/04_after_insertion.jpg)

* 由于一级索引链表的存在，比较次数几乎可以减少一半，虽然增加了 50 % 的额外存储空间，但性能提高了一倍。

以此类推，可以对一级索引再建索引，也就是二级索引，三级索引等。

### 2.2 多级索引
二级索引示例如下：

![05_second_index.jpg](https://github.com/wxdyhj/data-struct-go/blob/master/skip_list/jpg/05_second_index.jpg)

有了二级索引之后，新节点可以先和二级索引比较，确定大致范围，然后回归一级索引进行比较，进一步确定范围，最后回归原始链表，确定最终插入位置。假设索引创建合理，由于二级索引的存在，比较次数会变为原来的四分之一。

如果节点数足够多，可以创建更多级的索引，保证每一层是上一层节点数的一半。

当同一层链表只有 2 个节点时，停止继续向上创建更高级的索引，这样的多层链表结构，就是跳跃表。

假设每一级索引链表都构建合理，再假设原始链表的长度为 N，分析各级索引的比较次数如下：
* 不创建索引，在原始链表上的比较次数为 N
* 一级索引，N/2
* 二级索引，(N/2)/2=N/4
* 三级索引，(N/4)/2=N/8
* n 级索引，N/(2^n)
分析 n 的值
```
令 N/(2^n) = 1
则 2^n = N
两边同时取2的对数得：log2(2^n)=log2(N)
即：n=log2(N)
即索引的最大层级为 log2(N)，可类比为二叉树的树高。

二分查找，每比较一次，查找区间都会减半。
分析跳跃表的查找的复杂度，其实可以类比为二分查找，每创建一层索引，查找区间都减半。
```

### 2.3 选取索引分析
当大量新节点插入原始链表后，上层的索引节点会变得不够用，此时需要选取部分新节点作为索引节点。跳跃表的设计者采用 抛硬币 的方法，也就是通过随机的方法，以 50% 的概率将新节点选为上一层的索引。

* 沿用上述跳跃表，假设在原始链表插入新节点 9，示例如下：

![06_insert_with_index.jpg](https://github.com/wxdyhj/data-struct-go/blob/master/skip_list/jpg/06_insert_with_index.jpg)

* 第一次抛硬币，结果为正面，所以将 9 选为一级索引，示例如下：

![07_select_as_first_index.jpg](https://github.com/wxdyhj/data-struct-go/blob/master/skip_list/jpg/07_select_as_first_index.jpg)

* 第二次抛硬币，结果为反面，所以不再继续向上选取，示例如下：

![08_stop_to_second_index.jpg](https://github.com/wxdyhj/data-struct-go/blob/master/skip_list/jpg/08_stop_to_second_index.jpg)

由于跳跃表节点的插入和删除是不可预测的，很难用有效的算法来保证跳跃表的索引始终分布均匀，采用抛硬币的随机方法不能保证索引绝对均匀分布，但可以趋于均匀分布。

* 其实抛硬币的随机做法，也可以理解为以 p = 0.5 的概率向上一级选取索引
* 在 redis-6.0.5 的实现中，概率 p 的取值为 0.25

### 2.4 跳跃表的增删改查
#### 2.4.1 插入
假设原始链表的长度为 N，分析插入过程和复杂度如下：
* 新节点从最高级（假设为n）索引链表顺序比较，确定回归 n-1 级索引的位置，以此类推，最终回归原始链表，确定在原始链表的插入位置，时间复杂度为 O(log2(N))
* 在原始链表完成插入操作，时间复杂度为 O(1)
* 利用抛硬币的随机方式，决定新节点是否选取为上一级索引的节点，结果为证则选取并继续抛硬币，结果为反面则停止，时间复杂度为 O(log2(N))
* 因此，跳跃表的插入操作的时间复杂度为 O(log2(N))
* 分析空间复杂度：各层节点（不包括原始链表）总数为：N/2+N/4+N/8+...+2，等比数列，约等于 N，所以所需空间为 N，即空间复杂度为 O(N)

#### 2.4.2 删除
删除：先查找，找到待删除的节点，执行链表的删除操作即可，当然记得删除下一级索引上的节点，包括原始链表中的节点。如果某一层索引执行删除后只剩下一个节点，那么该层索引可以全部删掉（原始链表除外），因为只有一个节点的索引层没意义。

假设删除节点 6，示例如下：

![09_del_node.jpg](https://github.com/wxdyhj/data-struct-go/blob/master/skip_list/jpg/09_del_node.jpg)

删除后，由于二层索引只剩一个节点，因此整个二级索引都删除，示例如下：

![10_del_second_index.jpg](https://github.com/wxdyhj/data-struct-go/blob/master/skip_list/jpg/10_del_second_index.jpg)

整理跳跃表的删除操作如下：
* 自上而下，找到第一次出现节点的索引，并逐层找到每次对应的节点，时间复杂度为 O(log2(N))
* 在每层删除找到的节点，如果该层（非原始链表）只剩一个节点，则删除整层，时间复杂度为 O(log2(N))
* 因此跳跃表删除操作的时间复杂度为 O(log2(N))

#### 2.4.3 查找
查找过程与插入过程类似，与各级索引节点逐一比较，最终确定在原始链表的位置，时间复杂度为 O(log2(N))

#### 2.4.3 修改
修改与查找过程相似，先找到，进而修改节点的值即可，同时也需要修改各层索引上的值，时间复杂度为 O(log2(N))

## 3 跳跃表 vs 二叉搜索树 vs 哈希表
Binary Search Tree，简称 BST，中文可翻译为：二叉搜索树，二叉查找树或者二叉排序树。
二者的查找相同，都是 O(log2(N))

* 跳跃表和二叉搜索树是有序的，而哈希表是无序的。查找单个 key 时，哈希表的时间复杂度为 O(1)，而跳跃表和二叉搜索树均为 O(log2(N))
* 由于哈希表是无序的，所以无法实现范围查找
* 与二叉搜索树相比，跳跃表的优点：维持平衡的成本较低，跳跃表通过随机方法，而二叉搜索树需要调整二叉树的结构，逻辑复杂

## 4 参考资料
* [漫画：什么是跳表？](https://zhuanlan.zhihu.com/p/53975333)
